!!$////////////////////////////////////////////////////////////////////
!!$  Interface b/w MOPAC to GRRM  (ver1.2)
!!$   Yukihiro Ota           (otayuki@gmail.com)
!!$   Sergi Ruiz-Barragan
!!$   Motoyuki Shiga   
!!$
!!$   Last update: Aug 27th, 2015
!!$////////////////////////////////////////////////////////////////////
      program main
        use commn_var
        use commn_msg,only:                                         &
             header_err_msg, descript_std_msg
        implicit none
        
!!$---Local variables
        !! GRRM14
        character(len=32)  :: jobname,jobpref,jobkey
        character(len=32)  :: inpgen,outgen
        integer :: len_jobname,len_jobpref

        !! MOPAC
        character(len=32)  :: inpmoc,arcmoc,outmoc,bufmoc,jobmoc
        character(len=128) :: mockey
        integer :: nactv,natom,nfzen,natom_tot
        integer :: nvar,nvar_tot
        integer :: n_iter
        integer :: nl_hess,nl_hess_inc
        double precision :: energy
        double precision :: spinsq
        double precision :: grad
        double precision,allocatable :: hessian(:,:)

        !! Trajectory data
        character(len=32) :: trjxyz

        !! Buffers
        character(len=512) :: sh_command_str
        character(len=128)  :: line_buff
        character(len=16)  :: hbuff1,hbuff2,hbuff3,hbuff4,hbuff5
        character(len=16)  :: hbuff6,hbuff7,hbuff8,hbuff9,hbuff10
        character(len=6)   :: c_dum1,c_dum2,c_dum3
        character(len=50)  :: c_dum_l1,c_dum_l2,c_dum_l3,c_dum_l4
        integer :: ibuff,jbuff,kbuff
        integer :: I_NUMBER
        double precision :: xx, yy, zz

        !! Logical controllers
        logical :: L_EXIST,L_OPEN,Lloop

        !! Loop control variables
        integer :: iatm,invar,ii,jj,kk
 
!!$---START-START-START-START-START-START-START-START-START-START------

!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Set arguments
!!$---
!!$////////////////////////////////////////////////////////////////////

!!$---Get a single argument of this program
!!$---  This is automatically supplied by GRRM. 
!!$---  When GRRM input is named by "proj.com", the argument is 
!!$---  "proj_XX", where "_XX" depends on a kind of calculations 
!!$---  in GRRM. Typically, this is a process ID (e.g., _P0). 
!!$---  If no multi-process job is submitted, "_XX" is absent.
        ibuff=iargc()
        if( ibuff .ne. 1 ) then 
           call descript_std_msg ()
           stop
        end if
        call getarg(1,jobname)
        ibuff=index(jobname,'_')
        if ( ibuff .eq. 0 ) then
           jobpref=jobname
        else
           jobpref=jobname(1:ibuff-1)
        end if
        len_jobname=len_trim(jobname)
        len_jobpref=len_trim(jobpref)

!!$---  End of "Set arguments"


!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Prepare files
!!$---
!!$////////////////////////////////////////////////////////////////////

!!$---Make linkers to GRRM
!!$--- INPGEN: xxx_INP4GEN.rrm 
!!$---  => made from GRRM, and sent to MOPAC 
!!$--- OUTGEN: xxx_OUT4GEN.rrm 
!!$---  => made from MOPAC, and sent to GRRM 
        inpgen=jobname(1:len_jobname)//"_INP4GEN.rrm"
        outgen=jobname(1:len_jobname)//"_OUT4GEN.rrm"

        !! Check & open *****_INP4GEN.rrm
        inquire (FILE=inpgen,OPENED=L_OPEN,EXIST=L_EXIST,       &
             NUMBER=I_NUMBER)
        if ( .not. L_EXIST ) then
           call header_err_msg()
           write(6,*) "... ", inpgen
           write(6,*) " is not generated by GRRM14."
           stop
        end if
        open(unit_inpgen,FILE=inpgen,status='old')

        !! Open *****_OUT4GEN.rrm
        open(unit_outgen,FILE=outgen,status='replace')

!!$---Make trajectory data files
!!$--- trajectory data is stored in trj_****.xyz
        trjxyz="trj_"//jobname(1:len_jobname)//".xyz"
        open ( unit_trj, file= trjxyz, access = 'append' )

!!$---Set temporal files for MOPAC's IO
!!$--- Old files are automatically replaced.
!!$---  inpmoc: MOPAC input  (****.dat)
!!$---  outmoc: MOPAC output (****.out)
!!$---  bufmoc: Buffer file
        jobmoc=jobname(1:len_jobname)//"_MocJOB"
        inpmoc=jobname(1:len_jobname)//"_MocJOB.dat"
!!$        arcmoc=jobname(1:len_jobname)//"_MocJOB.arc"
        outmoc=jobname(1:len_jobname)//"_MocJOB.out"
        bufmoc=jobname(1:len_jobname)//"_MocJOB.buf"

        !! Open MOPAC input
        !! After running MOPAC, output files (.arc and .out)
        !! are opened. 
        open(unit_inpmoc,FILE=inpmoc,status='replace')

        !! Delete old MOPAC output files
!!$        inquire (FILE=arcmoc,OPENED=L_OPEN,EXIST=L_EXIST,    &
!!$             NUMBER=I_NUMBER)
!!$        if ( L_EXIST .eqv. .true. ) then
!!$           call system ('rm -f '//arcmoc)
!!$        end if
        inquire (FILE=outmoc,OPENED=L_OPEN,EXIST=L_EXIST,       &
             NUMBER=I_NUMBER)
        if ( L_EXIST .eqv. .true. ) then
           call system ('rm -f '//outmoc)
        end if

        !! Delete old buffer for MOPAC
        !!  This buffer file will be automatically deleted in the 
        !!  finalization of this program. 
        inquire (FILE=bufmoc,OPENED=L_OPEN,EXIST=L_EXIST,      &
             NUMBER=I_NUMBER)
        if ( L_EXIST .eqv. .true. ) then
           call system ('rm -f '//bufmoc)
        end if

!!$---Set a keyword file of MOPAC
!!$--- This user-supplied file summarize KEYWORDS in calculations
!!$--- by MOPAC (e.g., PM3 XYZ CHARGE=0 ).
!!$--- Note that KEYWORDS must be written by 1 line, within 128 
!!$--- characters. 
        jobkey=jobpref(1:len_jobpref)//".key"

!!$---  End of "Prepare files"


!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Prepare MOPAC input
!!$---
!!$////////////////////////////////////////////////////////////////////

!!$--- Read information from a MOPAC template file
!!$--- 1SCF, GRADIENTS, HESSIAN are automatically supplied, 
!!$--- depending on a kind of GRRM calculations
        inquire (FILE=jobkey,OPENED=L_OPEN,EXIST=L_EXIST,          &
             NUMBER=I_NUMBER)
        if ( .not. L_EXIST ) then
           call header_err_msg()
           write (6,*) "... ", jobkey
           write (6,*) " does not exist."
           stop
        end if


        open (unit_bufmoc,file=jobkey)
        read (unit_bufmoc,'(a128)') line_buff

        mockey=""
        ibuff=0
        kbuff=0

        Lloop = .true.
        do while ( Lloop )

           jbuff=index(line_buff(ibuff+1:120),' ')+ibuff

           Lloop = .not.(jbuff.eq.0)

           if ( index(line_buff(ibuff:jbuff)," OPT").eq.0 .and.        &
                index(line_buff(ibuff:jbuff)," GRADIENTS").eq.0 .and.  &
                index(line_buff(ibuff:jbuff)," 1SCF").eq.0 .and.       &
                index(line_buff(ibuff:jbuff)," FORCE").eq.0 .and.      &
                index(line_buff(ibuff:jbuff)," FREQCY").eq.0 .and.     &
                index(line_buff(ibuff:jbuff)," HESSIAN").eq.0 .and.    &
                index(line_buff(ibuff:jbuff)," EF").eq.0 .and.         &
                index(line_buff(ibuff:jbuff)," PRECISE").eq.0 .and.    &
                index(line_buff(ibuff:jbuff)," RESTART").eq.0 .and.    &
                line_buff(ibuff:jbuff).ne."  " ) THEN

              mockey=mockey(1:kbuff)//" "//line_buff(ibuff+1:jbuff)
              kbuff=kbuff+jbuff-ibuff

            ENDIF

            ibuff=jbuff

            Lloop = jbuff.ne.120
         

        enddo


        !! A shell script with call system is used:
        !! Several keywords are automatically removed if
        !! they are written in MOPAC KEYWORD file. 
        !! This is no so efficient. Please modify it!
!        write (sh_command_str,*)                                   &
!             "awk '{print $0}' ",                                  &
!             TRIM(jobkey),                                         &
!             "|sed 's/OPT//i' ",                                   &
!             "|sed 's/GRADIENTS//i' ",                             &
!             "|sed 's/1SCF//i' ",                                  &
!             "|sed 's/FORCE//i' ",                                 &
!             "|sed 's/FORCETS//i' ",                               &
!             "|sed 's/FREQCY//i' ",                                &
!             "|sed 's/HESSIAN//i' ",                               &
!             "|sed 's/EF//i' ",                                    &
!             "|sed 's/PRECISE//i' ",                               &
!             "|sed 's/RESTART//i' > ",                             &
!             TRIM(bufmoc)
!!$--- debug
        !!write(6,*) sh_command_str
!!$--- debug
!        call system (sh_command_str)
!        open (unit_bufmoc,file=bufmoc)
!        read (unit_bufmoc,'(a128)') mockey
!        close (unit_bufmoc)

!!$--- Read date in xxx_INP4GEN.rrm to build MOPAC input up
!!$---  Task section (Task: ... ) in *****_INP4GEN.rrm
!!$---  (Case of MICROITERATION is not implemented.)
        Lloop = .true.
        do while ( Lloop )
           read (unit_inpgen,'(a128)') line_buff
           if ( index(line_buff,"TASK:") .ne. 0 ) then 

              if ( index(line_buff,"GUESS") .ne. 0 ) then
                 mockey = TRIM(mockey)//" PRECISE OPT"
                 !! We NEVER use Hessian data. It means that
                 !! one has to set 'Derivative=Force' in GRRM input
!!$              else if ( index(line_buff,"HESSIAN") .ne. 0 ) then
!!$                 mockey = TRIM(mockey)//                          &
!!$                      " PRECISE OPT GRADIENTS HESSIAN EF"
!!$                 mockey = TRIM(mockey)//                         &
!!$                      " 1SCF GRADIENTS FORCE FREQCY"
              else if ( index(line_buff,"GRADIENT") .ne. 0 ) then
                 mockey = TRIM(mockey)//" 1SCF GRADIENTS"
              else 
                 mockey = TRIM(mockey)//" 1SCF"
              end if

              Lloop = .false. 
           end if
        end do

!!$--- Guess section (GUESS: ... ) in *****_INP4GEN.rrm
!!$--- Read MO data or not. We ALWAYS set NOT in this version.
        Lloop = .true.
        do while ( Lloop )
           read (unit_inpgen,'(a128)') line_buff
           if ( index(line_buff,"GUESS:") .ne. 0 ) then 
              !! No action in this verion. 
              Lloop = .false. 
           end if
        end do

!!$--- State section (STATE: ... ) in *****_INP4GEN.rrm
!!$--- Number of potential surfaces: The default value is 1. 
        Lloop = .true.
        do while ( Lloop )
           read (unit_inpgen,'(a128)') line_buff
           if ( index(line_buff,"STATE:") .ne. 0 ) then 
              !! No action in this version
              Lloop = .false. 
           end if
        end do

!!$--- Create header part of MOPAC input
        write (unit_inpmoc,*) TRIM(mockey)
        write (unit_inpmoc,*) "----comment----"
        write (unit_inpmoc,*) " "

!!$--- Atom section
!!$--- Typical structure In *****_INP4GEN.rrm:
!!$--- 
!!$--- NACTIVEATOM / NATOM: k / l
!!$--- A1       xxxxx     yyyyy     zzzzz
!!$--- A2       xxxxx     yyyyy     zzzzz
!!$---                ...
!!$--- Al       xxxxx     yyyyy     zzzzz
!!$--- NFROZENATOM: m
!!$--- D1       xxxxx     yyyyy     zzzzz
!!$--- D2       xxxxx     yyyyy     zzzzz
!!$---                ...
!!$--- Dm       xxxxx     yyyyy     zzzzz
!!$---
!!$--- [Note] When using external atoms in microiteration
!!$--- simulations, k is not equal to l. Otherwise, k=l.
        !! NACTIVEATOM / NATOM:
        Lloop = .true.
        do while ( Lloop )
           read (unit_inpgen,'(a128)') line_buff
           if ( index(line_buff,"NACTIVEATOM / NATOM:")            &
                .ne. 0 ) then 
              !! NACTIVEATOM
              c_dum_l1=                                            &
                   line_buff(index(line_buff,":")+1:               &
                   index(line_buff,"/",back=.true.)-1)
              read (c_dum_l1,*) nactv
              !! NATOM
              c_dum_l1=                                            &
                   line_buff(index(line_buff,"/",back=.true.)+1:   &
                   len(line_buff))
              read (c_dum_l1,*) natom
              Lloop = .false. 
           end if
        end do
        !! NFROZENATOM:
        rewind(unit_inpgen)
        nfzen = 0
        Lloop = .true.
        read (unit_inpgen,'(a128)') line_buff
        if ( index(line_buff,"NFROZENATOM:") .ne. 0 ) then 
           !! NFROZENATOM
           c_dum_l1=                                               &
                line_buff(index(line_buff,":")+1:                  &
                len(line_buff))
           read (c_dum_l1,*) nfzen
        end if

        !! Total number of atoms in MOPAC calculations
        natom_tot = natom+nfzen
        
        !! Write trajectory data (header)
        write ( unit_trj, '(1I5)') natom_tot
        write ( unit_trj, '(a)' ) jobname

        !! Read and write atomic coordinate data
        rewind(unit_inpgen)
        Lloop = .true.
        do while ( Lloop )
           read (unit_inpgen,'(a128)') line_buff
           if ( index(line_buff,"NACTIVEATOM / NATOM:")            &
                .ne. 0 ) then 
              Lloop = .false. 
           end if
        end do
        !! NACTIVEATOM / NATOM:
        do iatm=1,natom
           read (unit_inpgen,*) c_dum1, xx, yy, zz
           !! ... write atom data
           write (unit_inpmoc,                                     &
                '(1A5,F18.12,1I3,F18.12,1I3,F18.12,1I3)')          &
                c_dum1(1:3), xx, 1, yy, 1, zz, 1
           !! ... write trajectory data
           write (unit_trj,'(1A5,3F16.8)')                         &
                c_dum1(1:3), xx, yy, zz
        end do
        !! NFROZENATOM:
        if ( nfzen .ne. 0 ) then
           read (unit_inpgen,'(a128)') line_buff
           do iatm=1,nfzen
              read (unit_inpgen,*) c_dum1, xx, yy, zz
              !! ... write atom data
              write (unit_inpmoc,                                     &
                   '(1A5,F18.12,1I3,F18.12,1I3,F18.12,1I3)')          &
                   c_dum1(1:3), xx, 1, yy, 1, zz, 1
              !! ... write trajectory data
              write (unit_trj,'(1A5,3F16.8)')                         &
                   c_dum1(1:3), xx, yy, zz
           end do
        end if

!!$--- Finalization
        close (unit_inpgen)
        close (unit_inpmoc)
        close (unit_trj)

!!$---End of Prepare MOPAC input


!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Run MOPAC
!!$---
!!$--- You have to set PATH to the install location of MOPAC
!!$--- Alternatively, you may make a symbolic link to MOPAC 
!!$--- somewhere, such as /usr/local/bin
!!$////////////////////////////////////////////////////////////////////
        write(sh_command_str,*)                                    &
             "MOPAC2012.exe ",                                     &
             TRIM(jobmoc),                                         &
             " > ",                                                &
             TRIM(bufmoc),                                         &
             " 2>&1"
!!$--- debug
        !!write(6,*) sh_command_str
!!$--- debug
        call system (sh_command_str)

!!$---  End of "Run MOPAC"


!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Post-processing
!!$---
!!$////////////////////////////////////////////////////////////////////
        
!!$---Open MOPAC output files
        !! *****_MocJOB.out
        inquire (FILE=outmoc,OPENED=L_OPEN,EXIST=L_EXIST,          &
             NUMBER=I_NUMBER)
        if ( .not. L_EXIST ) then
           call header_err_msg ()
           write (6,*) "... mopac-grrm interface needs MOPAC outout"
           write (6,*) TRIM(outmoc)
           stop
        end if
        open (unit_outmoc,FILE=outmoc,status='old')

!!$        !! *****_MocJOB.arc
!!$        inquire (FILE=arcmoc,OPENED=L_OPEN,EXIST=L_EXIST,        &
!!$             NUMBER=I_NUMBER)
!!$        if ( .not. L_EXIST ) then
!!$           call header_err_msg ()
!!$           write (6,*) "... mopac-grrm interface needs MOPAC outout"
!!$           write (6,*) TRIM(arcmoc)
!!$           stop
!!$        end if
!!$        open (unit_arcmoc,FILE=arcmoc,status='old')

!!$---Create header part of *****_OUT4GEN.rrm
        write (unit_outgen,'("RESULTS")')

!!$---Write geometry without frozen atoms
        write (unit_outgen,'("CURRENT COORDINATE")')
        Lloop=.true.
        do while ( Lloop )
           read (unit_outmoc,'(a128)') line_buff
           if ( index(line_buff,"ATOM   CHEMICAL          X")      &
                .ne. 0 ) then 
              Lloop = .false.
           end if
        end do
        read (unit_outmoc,*)
        read (unit_outmoc,*)
        
        Lloop = .true.
        do while ( Lloop )
           read (unit_outmoc,'(a128)') line_buff
           if ( index(line_buff,"*") .ne. 0 ) then 
              read (line_buff,*)                                   &
                   iatm,c_dum_l1, xx, c_dum1, yy, c_dum2, zz
              !! The first "natom" coordinates are relevant to
              !! non-frozen atoms
              if ( iatm .le. natom ) then
                 write (unit_outgen,'(A3,2X,3F18.12)')             &
                      c_dum_l1(1:3), xx, yy, zz
              end if
           else
              Lloop = .false. 
           end if
        end do
!!$        Lloop=.true.
!!$        do while ( Lloop )
!!$           read (unit_arcmoc,'(a128)') line_buff
!!$           if ( index(line_buff,"FINAL GEOMETRY OBTAINED")       &
!!$                .ne. 0 ) then 
!!$              Lloop = .false.
!!$           end if
!!$        end do
!!$        read (unit_arcmoc,*)
!!$        read (unit_arcmoc,*)
!!$        read (unit_arcmoc,*)
!!$        do iatm=1,natom_tot
!!$           read (unit_arcmoc,*)                                  &
!!$                c_dum_l1, xx, c_dum1, yy, c_dum2, zz, c_dum3
!!$           !! The first "natom" coordinates are relevant to
!!$           !! non-frozen atoms
!!$           write (unit_outgen,'(A3,2X,3F18.12)')                 &
!!$                c_dum_l1(1:3), xx, yy, zz
!!$           if ( iatm .eq. natom ) exit
!!$        end do


!!$---Set degrees of freedom 
        !! check consistency
        if ( natom_tot .ne. iatm ) then
           call header_err_msg ()
           write (6,*) "... mopac-grrm interface encounters"
           write (6,*) "a serious error."
           write (6,*) "Number of total atoms in _INP4GEN.rrm "
           write (6,*) "(i.e., NATOM + NFROZENATOM) is not "
           write (6,*) "equal to that in MOPAC output."
           stop
        end if

        !! Degrees of freedom w/o frozen atoms
        nvar = 3*natom
        
        !! Total degrees of freedom
        nvar_tot = 3*natom_tot

!!$---Memory allocation and initilization of hessian
        allocate ( hessian(nvar_tot,nvar_tot) )
        hessian=0.0d0

!!$---Write the Energy
!!$--- ENERGY (Hartree)
!!$--- Keyword in xxx.out: "TOTAL ENERGY"
!!$---- Unit in MOPAC output: eV
        rewind (unit_outmoc)
        Lloop = .true.
        do while ( Lloop )
           read (unit_outmoc,'(a128)') line_buff
!!$---- Case of Keyword to be "ELECTRONIC ENERGY"
!!$           if ( index(line_buff,"ELECTRONIC ENERGY       =")     &
!!$                .ne. 0 ) then
!!$              Lloop = .false.
!!$              read (line_buff,*)                                 &
!!$                   c_dum_l1,c_dum_l2,c_dum1, energy, c_dum2,     &
!!$                   c_dum_l3,c_dum_l4,c_dum3
!!$              write (unit_outgen,'("ENERGY = ",3F18.12)')        &
!!$                   energy/ha_to_ev, 0.0d0, 0.0d0
!!$              write (unit_outgen,'("       = ",3F18.12)')        &
!!$                   0.0d0,0.0d0,0.0d0
!!$           end if
           if ( index(line_buff,"TOTAL ENERGY            =")      &
                .ne. 0 ) then
              Lloop = .false.
              read (line_buff,*)                                  &
                   c_dum_l1,c_dum_l2,c_dum1, energy, c_dum2
              write (unit_outgen,'("ENERGY = ",3F18.12)')         &
                   energy/ha_to_ev, 0.0d0, 0.0d0
              write (unit_outgen,'("       = ",3F18.12)')         &
                   0.0d0,0.0d0,0.0d0
           end if
        end do
        
!!$---Write the Spin
!!$--- S**2 
!!$--- RHF => S**2 is set as 0.0
!!$--- UHF => The value of (S**2) is read from MOPAC output
        if ( index(mockey,"UHF") .eq. 0 ) then
           write (unit_outgen,'("S**2   =    0.000000000000")')
        else
           Lloop = .true.
           do while ( Lloop )
              read (unit_outmoc,'(a128)') line_buff
              if ( index(line_buff,"(S**2)  =")                   &
                   .ne. 0 ) then
                 Lloop = .false.
                 read (line_buff,*)                               &
                      c_dum_l1,c_dum_l2,spinsq
                 write (unit_outgen,'("S**2   = ",1F18.12)')      &
                      spinsq
              end if
           end do
        end if

!!$--- Write the gradient
!!$--- GRADIENT (Hartree/Bohr)
!!$--- See MOPAC mannual 
!!$--- (www.openmopac.net/manual/gradients_discussion.html).
!!$--- Keyword in xxx.out: FINAL  POINT  AND  DERIVATIVES
!!$--- Unit in MOPAC output: (kcal/mol)/Angstrom
        rewind(unit_outmoc)
        write (unit_outgen,'("GRADIENT")')
        if ( index(mockey,"GRADIENTS") .eq. 0 ) then
           !! The first "nvar" components are relevant to 
           !! non-frozen atoms
           do invar=1,nvar
              write (unit_outgen,'(F18.12)') 0.0d0
           end do
        else
           Lloop = .true.
           do while ( Lloop )
              read (unit_outmoc,'(a128)') line_buff
              if ( index(line_buff,                               &
                   "FINAL  POINT  AND  DERIVATIVES") .ne. 0 ) then
                 Lloop = .false.
              end if
           end do
           read (unit_outmoc,*)
           read (unit_outmoc,*)
           !! The first "nvar" components are relevant to 
           !! non-frozen atoms
           do invar=1,nvar
              read (unit_outmoc,*)                                &
                   ibuff, jbuff, c_dum1, c_dum_l1, c_dum2,        &
                   xx, grad, c_dum_l2
              write (unit_outgen,'(F18.12)')                      &
                   (au_to_ang*grad)/ha_to_kcm
           end do
        end if

!!$--- Write DIPOLE MOMENT
        rewind(unit_outmoc)
        Lloop=.true.
        do while ( Lloop )
           read (unit_outmoc,'(a128)') line_buff
           if ( index(line_buff,"DIPOLE           X         Y")    &
                .ne. 0 ) then
              Lloop = .false.
              read (unit_outmoc,*)
              read (unit_outmoc,*)
              read (unit_outmoc,*) c_dum1, xx, yy, zz
              write (unit_outgen,'("DIPOLE = ",3F18.12)')          &
                   xx, yy, zz
           end if
        end do

!!$---write HESSIAN
!!$--- Hessian (Hartree/(Bohr)^2)
!!$--- Keyword in xxx.out: 
!!$-----------------------------------------------
!!$--- Hessian matrix from geometry optimization
!!$-----------------------------------------------
!!$--- or 
!!$-----------------------------------------------
!!$--- Symmetrized Hessian matrix in a FORCE calculation.
!!$--- See MOPAC mannual (www.openmopac.net/manual/hessian.html)
!!$-----------------------------------------------
!!$--- Unit in MOPAC output: (kcal/mol)/Angstrom^2
!!$--- [note]
!!$--- As long as one sets 'Derivative=Force' at GRRM input, 
!!$--- this part is not important (HESSIAN from MOPAC is not 
!!$--- required)
!!$---
!!$--- [Important note] Aug 19, 2015.
!!$--- Hessian output in MOPAC force calculations is 
!!$--- problematic. So, we NEVER use HESSIAN data. 
!!$--- It means that one has to set 
!!$--- 'Derivative=Force' in GRRM input
!!$---
        !! The first "(nvar)(nvar+1)/2" elements are  
        !! relevant to non-frozen atoms
        write (unit_outgen,'("HESSIAN")')
        n_iter = nvar/5
        if ( mod(nvar,5).gt.0 ) n_iter=n_iter+1
        do kk=1,n_iter
           do ii=1+((kk-1)*5),nvar
              write (unit_outgen,'(5F18.12)')                  &
                   (hessian(ii,jj),jj=1+((kk-1)*5),min(ii,kk*5))
           end do
        end do
!!$        rewind (unit_outmoc)
!!$        write (unit_outgen,'("HESSIAN")')
!!$        if ( index(mockey,"HESSIAN") .eq. 0 ) then
!!$           !! The first "(nvar)(nvar+1)/2" elements are  
!!$           !! relevant to non-frozen atoms
!!$           n_iter = nvar/5
!!$           if ( mod(nvar,5).gt.0 ) n_iter=n_iter+1
!!$           do kk=1,n_iter
!!$              do ii=1+((kk-1)*5),nvar
!!$                 write (unit_outgen,'(5F18.12)')                  &
!!$                      (hessian(ii,jj),jj=1+((kk-1)*5),min(ii,kk*5))
!!$              end do
!!$           end do
!!$        else
!!$           Lloop = .true.
!!$           do while ( Lloop )
!!$              read (unit_outmoc,'(a128)') line_buff
!!$              if ( index (line_buff,"Hessian matrix ")            &
!!$                   .ne. 0 ) then
!!$                 Lloop=.false.
!!$              end if
!!$           end do
!!$           !! This part is awkward. A much better way is desirable.
!!$           !! Open a buffer file
!!$           open (unit_bufmoc,FILE=bufmoc)
!!$           !! Count number of lines in HESSIAN data
!!$           nl_hess = 0
!!$           nl_hess_inc = 0
!!$           do ii=1,nvar_tot
!!$              nl_hess = nl_hess + 1 + nl_hess_inc
!!$              if ( mod(ii,10) .eq. 0 ) nl_hess_inc=nl_hess_inc+1
!!$           end do
!!$           !! Read every 10 entry and store it in buffer 
!!$           do ii=1,nl_hess
!!$              read (unit_outmoc,'(10a10)')                        &
!!$                   hbuff1, hbuff2, hbuff3,                        &
!!$                   hbuff4, hbuff5, hbuff6,                        &
!!$                   hbuff7, hbuff8, hbuff9,                        &
!!$                   hbuff10
!!$              write (unit_bufmoc,'(10a11)')                       &
!!$                   hbuff1(1:11),hbuff2(1:11),hbuff3(1:11),        &
!!$                   hbuff4(1:11),hbuff5(1:11),hbuff6(1:11),        &
!!$                   hbuff7(1:11),hbuff8(1:11),hbuff9(1:11),        &
!!$                   hbuff10(1:11)
!!$           end do
!!$           !! Rewind buffer
!!$           rewind(unit_bufmoc)
!!$           !! Extract HESSIAN data from buffer
!!$           do ii=1,nvar_tot
!!$              n_iter = ii/10
!!$              if ( mod(ii,10).gt.0 ) n_iter=n_iter+1
!!$              do kk=1,n_iter
!!$--- debug
!!$                 !!write(6,*) (jj,jj=1+((kk-1)*10),min(ii,kk*10))
!!$--- debug
!!$                 read (unit_bufmoc,*)                             &
!!$                      (hessian(ii,jj),jj=1+((kk-1)*10),min(ii,kk*10))
!!$              end do
!!$              do jj=1,ii
!!$                 hessian(ii,jj)=                                     &
!!$                      (hessian(ii,jj)*au_to_ang*au_to_ang)/ha_to_kcm
!!$              end do
!!$           end do
!!$           !! The first "(nvar)(nvar+1)/2" elements are  
!!$           !! relevant to non-frozen atoms
!!$           n_iter = nvar/5
!!$           if ( mod(nvar,5).gt.0 ) n_iter=n_iter+1
!!$           do kk=1,n_iter
!!$              do ii=1+((kk-1)*5),nvar
!!$                 write (unit_outgen,'(5F18.12)')                  &
!!$                      (hessian(ii,jj),jj=1+((kk-1)*5),min(ii,kk*5))
!!$              end do
!!$           end do
!!$           !! Close buffer
!!$           close (unit_bufmoc)
!!$        end if
        
!!$---Write the DIPOLE DERIVATIVES
        write (unit_outgen,'("DIPOLE DERIVATIVES")')
        !! The first "nvar" components are relevant to 
        !! non-frozen atoms
        do invar=1,nvar
           write (unit_outgen,'(3F18.12)') 0.0d0,0.0d0,0.0d0
        end do

!!$---Write the POLARIZABILITY
!!$--- See, e.g., Jensen's textbook (Sec.10.1)
        write (unit_outgen,'("POLARIZABILITY")')
        do ii=1,3
           write (unit_outgen,'(3F18.12)') (0.0d0,jj=1,ii)
        end do
        
!!$---Finalization
!!$        close (unit_arcmoc)
        close (unit_outmoc)
        close (unit_outgen)
        
!!$---  END of "Post-processing"


!!$////////////////////////////////////////////////////////////////////
!!$---
!!$---Finalization
!!$---
!!$////////////////////////////////////////////////////////////////////

        !! Delete buffer for MOPAC
        !!  For debug, keeping the buffer would be preferable. 
        inquire (FILE=bufmoc,OPENED=L_OPEN,EXIST=L_EXIST,       &
             NUMBER=I_NUMBER)
        if ( L_EXIST .eqv. .true. ) then
           call system ('rm -f '//bufmoc)
        end if

        !! Deallocation
        deallocate ( hessian )

        stop
      end program main
